# Cyoda Python Client Application Development Guide

This guide helps you build **Cyoda Python client applications** using the established patterns in this codebase. **Always reference `example_application/` for working examples** - don't reinvent the wheel.

## Core Principles
- **Interface-based design** - Extend CyodaEntity/CyodaProcessor base classes
- **Workflow-driven architecture** - All business logic flows through Cyoda workflows
- **Thin routes** - Pure proxies to EntityService with no business logic
- Entity updates must specify manual transitions explicitly

## Golden Rules
- Modify only the application directory.
- Statically check with `mypy .` early and often; fix errors immediately.
- Routes = thin proxies to EntityService (no business logic).
- Prefer technical IDs for performance.
- In processors, you cannot use entityService to update the current entity (read-only); The current entity will be updated automatically once you return from the processor.
  you may get/update/delete other entities via EntityService.
- **CRITICAL: Update using only manual transitions (never automatic).**

## IDs & Metadata

- **Technical ID (UUID, unique, immutable)**:
  `entity.id` - retrievable from CyodaEntity
- **Entity state**:
  `entity.state` - Entity state is managed by the workflow and you can not change it manually, you can only read it.
- **Business ID (user-defined, non-unique, mutable)**:
  retrievable/updatable with business ID–specific methods.
- **Update semantics**:
  - With transition → moves to that state.
  - Without transition → loops back to same state.
  - If in doubt, save without transition.

## Critical Rules
- **NEVER modify** `common/` directory - framework code only
- **ALWAYS validate workflows** against `example_application/resources/workflow/workflow_schema.json`
- **ALWAYS review requirements** in `application/resources/functional_requirements/`
- **ALWAYS run code quality checks**: `mypy`, `black`, `isort`, `flake8`, `bandit`
- **Use entity constants** (ENTITY_NAME/ENTITY_VERSION) instead of hardcoded strings
- **Follow example_application/ patterns exactly**

## Implementation Workflow

### 1. Prerequisites & Setup
```bash
python -m venv .venv && source .venv/bin/activate
pip install -e ".[dev]"
```

### 2. Study Requirements & Reference Implementation
**FIRST - Review functional requirements:**
- **Requirements**: `application/resources/functional_requirements/` - Contains all business requirements for your application

**Then examine reference patterns in `example_application/`:**
- **Entity**: `entity/example_entity.py` - Shows CyodaEntity extension patterns. Keep it minimal - just enough to satisfy the requirements.
- **Processor**: `processor/example_entity_processor.py` - Business logic implementation. Functions should follow KISS principle, just enough to satisfy the requirements.
- **Criterion**: `criterion/example_entity_validation_criterion.py` - Validation logic. Follow KISS principle, just enough to satisfy the requirements.
- **Workflow**: `resources/workflow/example_entity/version_1/ExampleEntity.json` - Workflow structure - must validate against `example_application/resources/workflow/workflow_schema.json`
- **Routes**: See `application/routes/` for API endpoint patterns

### 3. Create Your Entities for your application
Keep it minimal - just enough to satisfy the requirements.
**Location**: `application/entity/{{entity_name}}/version_1/{{entity_name}}.py`
- Extend `CyodaEntity` from `common.entity.cyoda_entity`
- Define `ENTITY_NAME` and `ENTITY_VERSION` constants
- Add business fields with Pydantic Field definitions
 If requirements mention "state" or "status", map them to `entity.meta.state` instead and explain this to the user.
State is managed by the workflow and you can not change it manually, you can only read it.
- **Reference**: `example_application/entity/example_entity.py`

### 4. Define Workflows: 1 workflow per entity
**Location**: `application/resources/workflow/{{entity_name}}/version_1/{{EntityName}}.json`
- Copy structure from `example_application/resources/workflow/example_entity/version_1/ExampleEntity.json`
- Use `"initial_state"` as initial state
- Set explicit `"manual": true/false` for all transitions
- Match processor names to your Python class names exactly
- **CRITICAL**: Validate against `example_application/resources/workflow/workflow_schema.json`
- **Reference**: `example_application/resources/workflow/example_entity/version_1/ExampleEntity.json`

   * Rules:
     * Each workflow must have an automatic transition from the initial state to the first state.
     * Loop transitions (to self or to a previous state) must be marked as manual.
     * Transitions can have **processors**, **criteria**, both, or none.
     * Do NOT complicate the workflow with complex criteria. Keep it simple unless the requirement explicitly calls for it.
     * Keep the number of processors minimum to comply with the requirement. If the requirement is not explicit - minimize the number of processors.
    * Minimise the number of processors and criteria. One processor can do multiple things. Try to keep up to 3 processors per entity unless the requirement explicitly calls for more.
     If the requirement is explicit - you must implement all the processors and criteria it requires.
   The name of the workflow must be the same as the entity name PascalCase. The number of processors and criteria in the workflow must match the number of processors and criteria in the workflow diagram exactly.
   * Path: `application/resources/workflow/<entityName>/version_1/<EntityName>.json` -- always `version_1`.
   * Validate each workflow against `example_application/resources/workflow/workflow_schema.json`.

### 5. Implement Processors
**Location**: `application/processor/{{entity_name}}_processor.py`
- Make sure you understand entity service interface common/service/entity_service.py
- Extend `CyodaProcessor` from `common.processor.base`
- Use `cast_entity()` for type-safe entity operations
- Access other entities via `get_entity_service()`
- No updates to current entity with the entityService - it will be updated automatically once you return; only get/update/delete other entities.
- To update another entity use EntityService: apply correct transition (manual only), or omit for loop-back.
- Check with example_application processors for reference.
- You do not need kwargs in processors. Just use entity as the argument, ignore any other arguments.
- Do not validate entity state in processors. Entity state is managed by the workflow.
- **Reference**: `example_application/processor/example_entity_processor.py`

**Critical:**
- Avoid validating CyodaEntity state. Entity state is managed by the workflow.
- Do NOT use CyodaEntity add_metadata and update_timestamp methods. You can only update concrete entities fields.
- You can get entity id, state etc directly from entity as it extends CyodaEntity.
- Run `mypy .` after implementing each processor to make sure it is correct.

### 6. Implement Criteria
- Implement under `application/criterion/`.
- Keep minimal and direct.
- You do not need kwargs in criteria. Just use entity as the argument, ignore any other arguments.
- Do not validate entity state in criteria. Entity state is managed by the workflow.
- **Reference**: `example_application/criterion/example_entity_validation_criterion.py`

### 7. Create API Routes
**Location**: `application/routes/{{entity_name}}s.py`
- Make sure you understand entity service interface common/service/entity_service.py
- Create Quart Blueprint with `/api/{{entity}}` prefix
- Use `get_entity_service()` for all CRUD operations
- Return technical IDs and entity states
- Endpoints must match requirements exactly; add CRUD if missing.
- Prefer technical IDs in responses.
- Update endpoints: transition nullable; must be manual if provided.
- Validate endpoints like in example_application routes.
- Import blueprints for the routes to application/app.py. Use example_application app.py as a reference.
- **Reference**: `application/routes/pets.py` or other route files
- Run `mypy .` after implementing each route to make sure it is correct.


### 8. Register Components
**Update `services/config.py`:**
- Add your processor/criterion modules to the `modules` list
- **Reference**: See existing module registration pattern

**Update `application/app.py`:**
- Register your route blueprints
- **Reference**: `application/app.py` for blueprint registration pattern

### 9. Testing & Validation

**Preconditions:**
Make sure there is no `__init__.py` file in the root of the mcp-cyoda-quart-app project. It will cause mypy to fail.
Just remove `__init__.py` from the root of the project if it exists. Do not restore it after the tests. This file should not be in the project root.
Then run `pip install -e ".[dev]"` to install all the dependencies.

**Tasks:**
Validate with:
```bash
python -m black .                    # Format code
python -m isort .                    # Sort imports
python -m mypy .                     # Type checking
python -m flake8 .                   # Style checking
```
Look for more details in PACKAGE_MANAGEMENT_GUIDE.md

## Key Patterns & Best Practices

### Entity Patterns
- Use business IDs for entity references, never technical UUIDs in data
- Cast entities with `cast_entity()` for type safety
- Define ENTITY_NAME/ENTITY_VERSION constants

### Processor Patterns
- Access other entities via `get_entity_service()`
- Use async/await for all operations
- Log business operations appropriately

### Route Patterns
- Thin proxies to EntityService only
- Return technical IDs in responses
- Use entity constants, not hardcoded strings

### Testing & Quality
- Run: `mypy`, `black`, `isort`, `flake8`, `bandit`

## Development Environment

### Setup
```bash
python -m venv .venv && source .venv/bin/activate
pip install -e ".[dev]"
```

### Code Quality
```bash
black . && isort . && mypy . && flake8 . && bandit -r . -x tests/
```

## Workflow Management

### Workflow Validation (CRITICAL!)
Validate your workflow files:
- **Schema**: `example_application/resources/workflow/workflow_schema.json`
- Ensure your workflow JSON matches the required schema structure
- Validate processor names match your Python class names exactly
The number of processors and criteria in the workflow must match the number of processors and criteria in the workflow diagram exactly.
There should be no missing or extra processors or criteria in application/criterion and application/processor directories. Each processor and criterion must exactly match the name in the workflow JSON.

## Acceptance Criteria

- Entities/processors/criteria/routers fully match functional requirements.
- The number of processors and criteria in the workflow must match the number of processors and criteria in the workflow JSONs exactly.
- Routes proxy only; no embedded business logic.
- Code modifies only application directory.
- Code passes quality checks.
- Requirements in application/resources/functional_requirements/ are satisfied.
- Summary documenting what was implemented can be found in the project root directory.
- **Critical: Keep criteria minimal and direct.**

## Completion Checklist
- [ ] **Requirements reviewed** from `application/resources/functional_requirements/`
- [ ] All entities extend CyodaEntity with ENTITY_NAME/ENTITY_VERSION constants
- [ ] All workflows validated against `example_application/resources/workflow/workflow_schema.json`
- [ ] All workflows use "initial_state" with explicit manual flags
- [ ] All processors extend CyodaProcessor and log execution
- [ ] All criteria implemented and minimal
- [ ] All routes are thin proxies to EntityService
- [ ] Code quality checks pass: `mypy`, `black`, `isort`, `flake8`, `bandit`
- [ ] No modifications to `common/` directory
- [ ] The number of processors and criteria in the workflow must match the number of processors and criteria in the workflow JSONs exactly.

CRITICAL: Make sure mypy passes before checking in the code.

## Parallelization Strategy
Parallelize the work on processors, criteria and routers if possible.
Each entity (with its workflow, processors, criteria, and routes) can be treated as an independent subtask.
Plan the work so that all the entities listed in functional requirements are implemented in the end of this task. If it takes too much resources to implement all the entities in parallel, then use placeholders for processors, criteria and routers and implement them in separate tasks.

Exit when all entities with all requirements are correctly implemented and build succeeds.
