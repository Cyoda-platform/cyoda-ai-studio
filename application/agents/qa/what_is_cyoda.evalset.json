{
  "eval_set_id": "what_is_cyoda",
  "name": "what_is_cyoda",
  "eval_cases": [
    {
      "eval_id": "case001dcd",
      "conversation": [
        {
          "invocation_id": "e-77fbe9d9-50ed-4125-ba1a-6809cc1b905d",
          "user_content": {
            "parts": [
              {
                "text": "what is cyoda"
              }
            ],
            "role": "user"
          },
          "final_response": {
            "parts": [
              {
                "text": "Cyoda is an event-driven platform for building, managing and automating business entities and workflows. It combines an entity service, a workflow/state engine, a processing framework, and a comprehensive API surface so product and engineering teams can model business objects, run stateful processes, and react to events in a scalable, auditable way.\n\nKey concepts (high level)\n- Entity-centric: Entities are the primary data model. Each entity has a technical ID, versions (ENTITY_VERSION), schema-driven data, and a lifecycle managed by workflows.\n- Event-driven processing: Changes, calculations and decisions are processed as events (calc, criteria, ack, error, keep_alive). Events flow through gRPC streams and are handled by registered processors.\n- Workflow engine: Workflows define states and transitions (manual or automatic). Entity state is managed by workflows (read-only from outside the workflow).\n- Processor framework: Modular processors (calcs, criteria, ack, error) execute business logic, validations, and side-effects. Processors are registered and executed via event routing.\n- API-first: Full REST/gRPC API for CRUD, search (including snapshot-based searches), workflow management, streams and OAuth/M2M authentication.\n- Observability & reliability: Versioning, event ack/error processors, and long-running streams support robustness in production systems.\n\nCore platform components\n- Entity Service: CRUD, versioning, schema validation, entity search.\n- Workflow Service: Define/import/export workflows, validate transitions, run tests, and manage state machines.\n- Stream/Event Router: gRPC-based streaming for delivering events to processors and clients; supports backpressure and reconnect patterns.\n- Processor Framework: Patterns for calc/criteria/ack/error processors to encapsulate business rules and side effects.\n- Authentication: OAuth 2.0 and machine-to-machine clients for secure API access.\n\nCommon use cases\n- Order / claim / ticket lifecycle automation (state transitions, validations, notifications)\n- Risk and decisioning (criteria processors + calc processors to score and route)\n- Integration hubs (event streams that transform and forward data to downstream systems)\n- Auditable business rules and approvals (workflow-driven manual transitions and audit trail)\n\nAPIs and docs\n- Public docs: https://docs.cyoda.net/\n- API reference (endpoints, request/response models): https://docs.cyoda.net/api-reference/scalar/\n- GitHub and community: https://github.com/Cyoda-platform and Discord invite in the docs\n\nBest practices (short)\n- Use technical IDs for internal references; keep business IDs for human-facing data.\n- Keep routes thin; delegate logic to processors/services.\n- Prefer manual transitions for externally-initiated changes to avoid unexpected state changes.\n- Treat entity state as workflow-managed and read-only outside transitions.\n\nIf you want, I can:\n- Show the exact API endpoints for creating/searching entities.\n- Walk through a sample workflow definition and how to import it.\n- Explain the event lifecycle (how a change becomes an event, how processors handle it).\nWhich would you like next?"
              }
            ],
            "role": "model"
          },
          "intermediate_data": {},
          "creation_timestamp": 1767716999.818957
        }
      ],
      "session_input": {
        "app_name": "qa",
        "user_id": "user"
      },
      "creation_timestamp": 1767717078.5262659
    }
  ],
  "creation_timestamp": 1767717052.8216293
}